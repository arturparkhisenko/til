# CPP tasks

- translate this tasks to en

# 1 

```
Масив – це впорядкована послідовність змінних одного типа. Кожному елементу масиву відводиться один елемент пам'яті. Елементи одного масиву займають послідовно розташовані елементи пам'яті. Всі елементи мають одне ім'я - ім'я масиву і відрізняються індексами – порядковими номерами в масиві. Кількість елементів в масиві називається його розміром. Щоб відвести в пам'яті потрібну кількість вічок для розміщення масиву, треба заздалегідь знати його розмір. Резервування пам'яті для масиву виконується на етапі компіляції програми.
Визначення масиву в Си/Си++:
 int а[100];//массив з 100 елементів цілого типа
Щоб звернутися до елементу масиву, треба вказати ім'я масиву і номер елементу в масиві (індекс): 
а[0] – індекс задається як константа, 
а[55] – індекс задається як константа, 
а[I] – індекс задається як змінна, 
а[2*i] – індекс задається як вираження. 
Елементи масиву можна задавати при його визначенні: 
int а[10]={1,2,3,4,5,6,7,8,9,10} ; 
int а[10]={1,2,3,4,5};
Якщо кількість початкових значень менша, ніж оголошена довжина масиву, то початкові елементи масиву отримають лише перші елементи.
int a[]={1,2,3,4,5}; 
Довжина масиву розраховується компілятором по кількості значень, перерахованих при ініціалізації.
Багатовимірний масив це масив, елементами якого служать масиви.
Ініціалізація багатовимірних масивів виконується аналогічно одновимірним масивам. Приклади: 
int а[3][4] = {
  {11,22,33,44},
  {55,66,77,88},
  {99,110,120,130}
}; //проініціалізовані всі елементи масиву
 int b[3][4]= {{1},{2},{3}};
// проініціалізовані перші елементи кожного рядка
 int с[3][2]={1,2,3,4,5,6}; // проініціалізовані всі елементи масиву
```

# 2

```
Файл - це іменована область зовнішньої пам'яті. Файл має такі характерні особливості:
1. має ім'я на диску, що дає можливість програмам працювати з
декількома файлами;
2. довжина файлу обмежується лише розміром диска.
Особливістю С є відсутність в цій мові структурованих файлів. Всі файли розглядаються як не структурована послідовність байтів. при такому підході поняття файлу поширюється і на різні пристрої. Одні і ті ж функції використовуються як для обміну даними з файлами, так і для обміну з пристроями.
Бібліотека С підтримує три рівні введення-виведення:
- Потоковий ввід-висновок;
- Введення-виведення нижнього рівня;
- Введення-виведення для консолі портів (залежить від конкретної ОС).
Розглянемо потоковий ввід-висновок.
На рівні потокового вводу-виводу обмін даними проводиться побайтно, тобто за одне звернення до пристрою (файлу) проводиться зчитування або запис фіксований порції даних (512 або 1024 байта). При введенні з диска або при зчитуванні з файлу дані містяться в буфер ОС, а потім побайтно або порціями передаються програмі користувача. При виведенні в файл дані також накопичуються в буфері, а при заповнення буфера записуються у вигляді єдиного блоку на диск. Буфери ОС реалізуються у вигляді
ділянок основної пам'яті. Т. О. потік - це файл разом з наданими коштами буферизації. Функції бібліотеки С, підтримують обмін даними на рівні потоку дозволяють обробляти дані різних розмірів і форматів. При роботі з потоком можна:
1. Відкривати і закривати потоки (при цьому покажчики на потік зв'язуються з конкретними файлами);
2. Вводити і виводити рядки, символи, форматуватині дані, порції даних довільної довжини;
3. Управляти буферизацією потоку і розміром буфера;
4. Отримувати і встановлювати покажчик поточної позиції в файлі.
Прототипи функцій вводу-виводу знаходяться в заголовному файлі <stdio.h>, которий також містить визначення констант, типів і структур, необхідних для обміну з потоком.
Перш, ніж почати працювати з потоком, його треба ініціювати, тобто відкрити. При цьому потік пов'язується зі структурою зумовленого типу FILE, визначення которій знаходиться у файлі <stdio.h>. У структурі знаходиться покажчик на буфер, покажчик на поточну позицію і т. п. При відкритті потоку повертається вказівник на потік, тобто на об'єкт типу FILE. Покажчик на потік повинен бути оголошений таким чином:
# include <stdio.h>
. . . . . . . .
FILE * f;/ / покажчик на потік
Покажчик на потік набуває значення в результаті виконання функції відкриття потоку:
FILE * fopen (const char * filename, const char * mode);
де const char * filename - рядок, який містить ім'я файлу, пов'язаного з потоком,
const char * mode - рядок режимів відкриття файлу.
наприклад:
f = fopen ("t.txt", "r");
де t.txt - ім'я файлу, r - режим відкриття файлу.
Коли програма починає виконуватися, автоматично відкриваються кілька потоків, з яких основними є:
- Стандартний потік вводу (stdin);
- Стандартний потік виводу (stdout);
- Стандартний потік виводу про помилки (stderr).
За замовчуванням stdin ставиться у відповідність клавіатура, а потокам stdout і stderr монітор. Для вводу-виводу за допомогою стандартних потоків використовуються функції:
- Getchar () / putchar () - введення-виведення окремого символу;
- Gets () / puts () - введення-виведення рядка;
- Scanf () / printf () - форматований введення / виведення.
Функції розглядалися, коли ми розглядали рядкові та символьні данні. Тепер ми можемо пов'язати їх зі стандартними потоками: введення здійснюється з стандартного потоку stdin висновок здійснюється в стандартний потік stdout. Аналогічно роботі зі стандартними потоками виконується введення-виведення в потоки, пов'язані з файлами.
Для символьного введення-виведення використовуються функції:
- Int fgetc (FILE * fp), де fp - покажчик на потік, з якого виконується зчитування. Функція повертає черговий символ у формі int з потоку fp. Якщо символ не может бути прочитаний, то повертається значення EOF.
- Int fputc (int c, FILE * fp), де fp - покажчик на потік, в який виконується запідпис, c - змінна типу int, в якій міститься записуваний в потік символ. функція повертає записаний в потік fp символ у формі int. Якщо символ не може бути записаний, то повертається значення EOF.
```
